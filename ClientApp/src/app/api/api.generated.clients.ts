//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class LIVLensAPIClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://livlens.azurewebsites.net";

    }

    brands_GetAll(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Brands";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBrands_GetAll(_response);
        });
    }

    protected processBrands_GetAll(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    brands_Post(value: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Brands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBrands_Post(_response);
        });
    }

    protected processBrands_Post(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    brands_Get(id: number , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Brands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBrands_Get(_response);
        });
    }

    protected processBrands_Get(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    brands_Put(id: number, value: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Brands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBrands_Put(_response);
        });
    }

    protected processBrands_Put(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    brands_Delete(id: number , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Brands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBrands_Delete(_response);
        });
    }

    protected processBrands_Delete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    equipment_GetClubs(  cancelToken?: CancelToken | undefined): Promise<ClubDim[]> {
        let url_ = this.baseUrl + "/api/Equipment/clubs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEquipment_GetClubs(_response);
        });
    }

    protected processEquipment_GetClubs(response: AxiosResponse): Promise<ClubDim[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClubDim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ClubDim[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClubDim[]>(null as any);
    }

    equipment_GetBrandModels(  cancelToken?: CancelToken | undefined): Promise<BrandModelDim[]> {
        let url_ = this.baseUrl + "/api/Equipment/brand-models";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEquipment_GetBrandModels(_response);
        });
    }

    protected processEquipment_GetBrandModels(response: AxiosResponse): Promise<BrandModelDim[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BrandModelDim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BrandModelDim[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BrandModelDim[]>(null as any);
    }

    equipment_GetProductTypes(  cancelToken?: CancelToken | undefined): Promise<ProductTypeDim[]> {
        let url_ = this.baseUrl + "/api/Equipment/product-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEquipment_GetProductTypes(_response);
        });
    }

    protected processEquipment_GetProductTypes(response: AxiosResponse): Promise<ProductTypeDim[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductTypeDim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ProductTypeDim[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductTypeDim[]>(null as any);
    }

    events_GetAll(  cancelToken?: CancelToken | undefined): Promise<EventDim[]> {
        let url_ = this.baseUrl + "/api/Events";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvents_GetAll(_response);
        });
    }

    protected processEvents_GetAll(response: AxiosResponse): Promise<EventDim[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EventDim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<EventDim[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EventDim[]>(null as any);
    }

    events_Post(newEvent: EventDim , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newEvent);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvents_Post(_response);
        });
    }

    protected processEvents_Post(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    events_Get(id: number , cancelToken?: CancelToken | undefined): Promise<EventDim> {
        let url_ = this.baseUrl + "/api/Events/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvents_Get(_response);
        });
    }

    protected processEvents_Get(response: AxiosResponse): Promise<EventDim> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EventDim.fromJS(resultData200);
            return Promise.resolve<EventDim>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EventDim>(null as any);
    }

    events_Put(id: number, updatedEvent: EventDim , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Events/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedEvent);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvents_Put(_response);
        });
    }

    protected processEvents_Put(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    events_Delete(id: number , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Events/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvents_Delete(_response);
        });
    }

    protected processEvents_Delete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    players_GetAll(  cancelToken?: CancelToken | undefined): Promise<PlayerDim[]> {
        let url_ = this.baseUrl + "/api/Players";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlayers_GetAll(_response);
        });
    }

    protected processPlayers_GetAll(response: AxiosResponse): Promise<PlayerDim[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlayerDim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PlayerDim[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlayerDim[]>(null as any);
    }

    players_Post(newPlayer: PlayerDim , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Players";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newPlayer);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlayers_Post(_response);
        });
    }

    protected processPlayers_Post(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    players_Get(id: number , cancelToken?: CancelToken | undefined): Promise<PlayerDim> {
        let url_ = this.baseUrl + "/api/Players/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlayers_Get(_response);
        });
    }

    protected processPlayers_Get(response: AxiosResponse): Promise<PlayerDim> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlayerDim.fromJS(resultData200);
            return Promise.resolve<PlayerDim>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlayerDim>(null as any);
    }

    players_Put(id: number, updatedPlayer: PlayerDim , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Players/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedPlayer);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlayers_Put(_response);
        });
    }

    protected processPlayers_Put(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    players_Delete(id: number , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Players/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlayers_Delete(_response);
        });
    }

    protected processPlayers_Delete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    weatherForecast_Get(  cancelToken?: CancelToken | undefined): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWeatherForecast_Get(_response);
        });
    }

    protected processWeatherForecast_Get(response: AxiosResponse): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<WeatherForecast[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WeatherForecast[]>(null as any);
    }
}

export class ClubDim implements IClubDim {
    clubId!: number;
    brandId?: number | undefined;
    manufacturer!: string;
    model!: string;
    surveyFacts!: SurveyFact[];

    constructor(data?: IClubDim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.surveyFacts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clubId = _data["clubId"];
            this.brandId = _data["brandId"];
            this.manufacturer = _data["manufacturer"];
            this.model = _data["model"];
            if (Array.isArray(_data["surveyFacts"])) {
                this.surveyFacts = [] as any;
                for (let item of _data["surveyFacts"])
                    this.surveyFacts!.push(SurveyFact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClubDim {
        data = typeof data === 'object' ? data : {};
        let result = new ClubDim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clubId"] = this.clubId;
        data["brandId"] = this.brandId;
        data["manufacturer"] = this.manufacturer;
        data["model"] = this.model;
        if (Array.isArray(this.surveyFacts)) {
            data["surveyFacts"] = [];
            for (let item of this.surveyFacts)
                data["surveyFacts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClubDim {
    clubId: number;
    brandId?: number | undefined;
    manufacturer: string;
    model: string;
    surveyFacts: SurveyFact[];
}

export class SurveyFact implements ISurveyFact {
    surveyId!: number;
    eventPlayerId!: number;
    productTypeId!: number;
    brandId?: number | undefined;
    clubId?: number | undefined;
    addDate!: Date;
    updateDate!: Date;
    brand?: BrandDim | undefined;
    club?: ClubDim | undefined;
    eventPlayer!: EventPlayerDim;
    productType!: ProductTypeDim;

    constructor(data?: ISurveyFact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.eventPlayer = new EventPlayerDim();
            this.productType = new ProductTypeDim();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surveyId = _data["surveyId"];
            this.eventPlayerId = _data["eventPlayerId"];
            this.productTypeId = _data["productTypeId"];
            this.brandId = _data["brandId"];
            this.clubId = _data["clubId"];
            this.addDate = _data["addDate"] ? new Date(_data["addDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.brand = _data["brand"] ? BrandDim.fromJS(_data["brand"]) : <any>undefined;
            this.club = _data["club"] ? ClubDim.fromJS(_data["club"]) : <any>undefined;
            this.eventPlayer = _data["eventPlayer"] ? EventPlayerDim.fromJS(_data["eventPlayer"]) : new EventPlayerDim();
            this.productType = _data["productType"] ? ProductTypeDim.fromJS(_data["productType"]) : new ProductTypeDim();
        }
    }

    static fromJS(data: any): SurveyFact {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyFact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyId"] = this.surveyId;
        data["eventPlayerId"] = this.eventPlayerId;
        data["productTypeId"] = this.productTypeId;
        data["brandId"] = this.brandId;
        data["clubId"] = this.clubId;
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["club"] = this.club ? this.club.toJSON() : <any>undefined;
        data["eventPlayer"] = this.eventPlayer ? this.eventPlayer.toJSON() : <any>undefined;
        data["productType"] = this.productType ? this.productType.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISurveyFact {
    surveyId: number;
    eventPlayerId: number;
    productTypeId: number;
    brandId?: number | undefined;
    clubId?: number | undefined;
    addDate: Date;
    updateDate: Date;
    brand?: BrandDim | undefined;
    club?: ClubDim | undefined;
    eventPlayer: EventPlayerDim;
    productType: ProductTypeDim;
}

export class BrandDim implements IBrandDim {
    brandId!: number;
    brand!: string;
    addDate!: Date;
    updateDate!: Date;
    surveyFacts!: SurveyFact[];

    constructor(data?: IBrandDim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.surveyFacts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.brand = _data["brand"];
            this.addDate = _data["addDate"] ? new Date(_data["addDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["surveyFacts"])) {
                this.surveyFacts = [] as any;
                for (let item of _data["surveyFacts"])
                    this.surveyFacts!.push(SurveyFact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrandDim {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["brand"] = this.brand;
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        if (Array.isArray(this.surveyFacts)) {
            data["surveyFacts"] = [];
            for (let item of this.surveyFacts)
                data["surveyFacts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBrandDim {
    brandId: number;
    brand: string;
    addDate: Date;
    updateDate: Date;
    surveyFacts: SurveyFact[];
}

export class EventPlayerDim implements IEventPlayerDim {
    eventPlayerId!: number;
    eventId!: number;
    playerId!: number;
    teeTime?: Date | undefined;
    playedInd!: number;
    addDate!: Date;
    updateDate!: Date;
    event!: EventDim;
    player!: PlayerDim;
    surveyFacts!: SurveyFact[];

    constructor(data?: IEventPlayerDim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.event = new EventDim();
            this.player = new PlayerDim();
            this.surveyFacts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventPlayerId = _data["eventPlayerId"];
            this.eventId = _data["eventId"];
            this.playerId = _data["playerId"];
            this.teeTime = _data["teeTime"] ? new Date(_data["teeTime"].toString()) : <any>undefined;
            this.playedInd = _data["playedInd"];
            this.addDate = _data["addDate"] ? new Date(_data["addDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.event = _data["event"] ? EventDim.fromJS(_data["event"]) : new EventDim();
            this.player = _data["player"] ? PlayerDim.fromJS(_data["player"]) : new PlayerDim();
            if (Array.isArray(_data["surveyFacts"])) {
                this.surveyFacts = [] as any;
                for (let item of _data["surveyFacts"])
                    this.surveyFacts!.push(SurveyFact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EventPlayerDim {
        data = typeof data === 'object' ? data : {};
        let result = new EventPlayerDim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventPlayerId"] = this.eventPlayerId;
        data["eventId"] = this.eventId;
        data["playerId"] = this.playerId;
        data["teeTime"] = this.teeTime ? this.teeTime.toISOString() : <any>undefined;
        data["playedInd"] = this.playedInd;
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["player"] = this.player ? this.player.toJSON() : <any>undefined;
        if (Array.isArray(this.surveyFacts)) {
            data["surveyFacts"] = [];
            for (let item of this.surveyFacts)
                data["surveyFacts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEventPlayerDim {
    eventPlayerId: number;
    eventId: number;
    playerId: number;
    teeTime?: Date | undefined;
    playedInd: number;
    addDate: Date;
    updateDate: Date;
    event: EventDim;
    player: PlayerDim;
    surveyFacts: SurveyFact[];
}

export class EventDim implements IEventDim {
    eventId!: number;
    eventName!: string;
    city!: string;
    state!: string;
    country!: string;
    courseName!: string;
    eventDate!: Date;
    addDate!: Date;
    updateDate!: Date;
    eventPlayerDims!: EventPlayerDim[];

    constructor(data?: IEventDim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.eventPlayerDims = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.eventName = _data["eventName"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.courseName = _data["courseName"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
            this.addDate = _data["addDate"] ? new Date(_data["addDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["eventPlayerDims"])) {
                this.eventPlayerDims = [] as any;
                for (let item of _data["eventPlayerDims"])
                    this.eventPlayerDims!.push(EventPlayerDim.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EventDim {
        data = typeof data === 'object' ? data : {};
        let result = new EventDim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["eventName"] = this.eventName;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["courseName"] = this.courseName;
        data["eventDate"] = this.eventDate ? this.eventDate.toISOString() : <any>undefined;
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        if (Array.isArray(this.eventPlayerDims)) {
            data["eventPlayerDims"] = [];
            for (let item of this.eventPlayerDims)
                data["eventPlayerDims"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEventDim {
    eventId: number;
    eventName: string;
    city: string;
    state: string;
    country: string;
    courseName: string;
    eventDate: Date;
    addDate: Date;
    updateDate: Date;
    eventPlayerDims: EventPlayerDim[];
}

export class PlayerDim implements IPlayerDim {
    playerId!: number;
    firstName!: string;
    lastName!: string;
    dob?: string | undefined;
    gender?: string | undefined;
    countryName?: string | undefined;
    countryCode?: string | undefined;
    amateur?: number | undefined;
    addDate!: Date;
    updateDate!: Date;
    eventPlayerDims!: EventPlayerDim[];

    constructor(data?: IPlayerDim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.eventPlayerDims = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dob = _data["dob"];
            this.gender = _data["gender"];
            this.countryName = _data["countryName"];
            this.countryCode = _data["countryCode"];
            this.amateur = _data["amateur"];
            this.addDate = _data["addDate"] ? new Date(_data["addDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["eventPlayerDims"])) {
                this.eventPlayerDims = [] as any;
                for (let item of _data["eventPlayerDims"])
                    this.eventPlayerDims!.push(EventPlayerDim.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlayerDim {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerDim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dob"] = this.dob;
        data["gender"] = this.gender;
        data["countryName"] = this.countryName;
        data["countryCode"] = this.countryCode;
        data["amateur"] = this.amateur;
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        if (Array.isArray(this.eventPlayerDims)) {
            data["eventPlayerDims"] = [];
            for (let item of this.eventPlayerDims)
                data["eventPlayerDims"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPlayerDim {
    playerId: number;
    firstName: string;
    lastName: string;
    dob?: string | undefined;
    gender?: string | undefined;
    countryName?: string | undefined;
    countryCode?: string | undefined;
    amateur?: number | undefined;
    addDate: Date;
    updateDate: Date;
    eventPlayerDims: EventPlayerDim[];
}

export class ProductTypeDim implements IProductTypeDim {
    productTypeId!: number;
    productCategory!: string;
    productSubCategory?: string | undefined;
    productType!: string;
    addDate!: Date;
    updateDate!: Date;
    surveyFacts!: SurveyFact[];

    constructor(data?: IProductTypeDim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.surveyFacts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productTypeId = _data["productTypeId"];
            this.productCategory = _data["productCategory"];
            this.productSubCategory = _data["productSubCategory"];
            this.productType = _data["productType"];
            this.addDate = _data["addDate"] ? new Date(_data["addDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["surveyFacts"])) {
                this.surveyFacts = [] as any;
                for (let item of _data["surveyFacts"])
                    this.surveyFacts!.push(SurveyFact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductTypeDim {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeDim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productTypeId"] = this.productTypeId;
        data["productCategory"] = this.productCategory;
        data["productSubCategory"] = this.productSubCategory;
        data["productType"] = this.productType;
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        if (Array.isArray(this.surveyFacts)) {
            data["surveyFacts"] = [];
            for (let item of this.surveyFacts)
                data["surveyFacts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductTypeDim {
    productTypeId: number;
    productCategory: string;
    productSubCategory?: string | undefined;
    productType: string;
    addDate: Date;
    updateDate: Date;
    surveyFacts: SurveyFact[];
}

export class BrandModelDim implements IBrandModelDim {
    brandModelId!: number;
    brand!: string;
    model!: string;
    addDate!: Date;
    updateDate!: Date;

    constructor(data?: IBrandModelDim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandModelId = _data["brandModelId"];
            this.brand = _data["brand"];
            this.model = _data["model"];
            this.addDate = _data["addDate"] ? new Date(_data["addDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BrandModelDim {
        data = typeof data === 'object' ? data : {};
        let result = new BrandModelDim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandModelId"] = this.brandModelId;
        data["brand"] = this.brand;
        data["model"] = this.model;
        data["addDate"] = this.addDate ? this.addDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBrandModelDim {
    brandModelId: number;
    brand: string;
    model: string;
    addDate: Date;
    updateDate: Date;
}

export class WeatherForecast implements IWeatherForecast {
    date!: Date;
    temperatureC!: number;
    temperatureF!: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date: Date;
    temperatureC: number;
    temperatureF: number;
    summary?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}